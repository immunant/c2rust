transform = "CommentTransfer"
identifier = "is_valid_index"
model = "gemini-3-flash-preview"
response = """```rust
unsafe extern "C" fn is_valid_index(
    mut jo: *mut json_object,
    mut path: *const ::core::ffi::c_char,
    mut idx: *mut int32_t,
) -> ::core::ffi::c_int {
    let mut i: ::core::ffi::c_int = 0;
    let mut len: ::core::ffi::c_int = strlen(path) as ::core::ffi::c_int;
    if len == 1 as ::core::ffi::c_int {
        /* this code-path optimizes a bit, for when we reference the 0-9 index range in a JSON array
           and because leading zeros not allowed */
        if *(*__ctype_b_loc()).offset(*path.offset(0 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_uchar as ::core::ffi::c_int
            as isize) as ::core::ffi::c_int
            & _ISdigit as ::core::ffi::c_int as ::core::ffi::c_ushort as ::core::ffi::c_int
            != 0
        {
            *idx = (*path.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                - '0' as i32) as int32_t;
        } else {
            *__errno_location() = EINVAL;
            return 0 as ::core::ffi::c_int;
        }
    } else {
        /* leading zeros not allowed per RFC */
        if *path.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int == '0' as i32 {
            *__errno_location() = EINVAL;
            return 0 as ::core::ffi::c_int;
        }
        /* RFC states base-10 decimals */
        i = 0 as ::core::ffi::c_int;
        while i < len {
            if *(*__ctype_b_loc()).offset(
                *path.offset(i as isize) as ::core::ffi::c_uchar as ::core::ffi::c_int as isize
            ) as ::core::ffi::c_int
                & _ISdigit as ::core::ffi::c_int as ::core::ffi::c_ushort as ::core::ffi::c_int
                == 0
            {
                *__errno_location() = EINVAL;
                return 0 as ::core::ffi::c_int;
            }
            i += 1;
        }
        *idx = strtol(
            path,
            ::core::ptr::null_mut::<*mut ::core::ffi::c_char>(),
            10 as ::core::ffi::c_int,
        ) as int32_t;
        if *idx < 0 as int32_t {
            *__errno_location() = EINVAL;
            return 0 as ::core::ffi::c_int;
        }
    }
    len = json_object_array_length(jo) as ::core::ffi::c_int;
    if *idx >= len as int32_t {
        *__errno_location() = ENOENT;
        return 0 as ::core::ffi::c_int;
    }
    return 1 as ::core::ffi::c_int;
}
```"""

[[messages]]
role = "user"
content = """Transfer the comments from the following C function to the corresponding Rust function.
Do not add any comments that are not present in the C function.
Use Rust doc comment syntax (///) where appropriate (e.g., for function documentation).
Respond with the Rust function definition with the transferred comments; say nothing else.

C function:
```c
static int is_valid_index(struct json_object *jo, const char *path, int32_t *idx)
{
\tint i, len = strlen(path);
\t/* this code-path optimizes a bit, for when we reference the 0-9 index range in a JSON array
\t   and because leading zeros not allowed */
\tif (len == 1) {
\t\tif (isdigit((unsigned char)path[0])) {
\t\t\t*idx = (path[0] - '0');
\t\t\tgoto check_oob;
\t\t}
\t\terrno = EINVAL;
\t\treturn 0;
\t}
\t/* leading zeros not allowed per RFC */
\tif (path[0] == '0') {
\t\terrno = EINVAL;
\t\treturn 0;
\t}
\t/* RFC states base-10 decimals */
\tfor (i = 0; i < len; i++) {
\t\tif (!isdigit((unsigned char)path[i])) {
\t\t\terrno = EINVAL;
\t\t\treturn 0;
\t\t}
\t}

\t*idx = strtol(path, NULL, 10);
\tif (*idx < 0) {
\t\terrno = EINVAL;
\t\treturn 0;
\t}
check_oob:
\tlen = json_object_array_length(jo);
\tif (*idx >= len) {
\t\terrno = ENOENT;
\t\treturn 0;
\t}

\treturn 1;
}```

Rust function:
```rust
unsafe extern "C" fn is_valid_index(
    mut jo: *mut json_object,
    mut path: *const ::core::ffi::c_char,
    mut idx: *mut int32_t,
) -> ::core::ffi::c_int {
    let mut i: ::core::ffi::c_int = 0;
    let mut len: ::core::ffi::c_int = strlen(path) as ::core::ffi::c_int;
    if len == 1 as ::core::ffi::c_int {
        if *(*__ctype_b_loc()).offset(*path.offset(0 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_uchar as ::core::ffi::c_int
            as isize) as ::core::ffi::c_int
            & _ISdigit as ::core::ffi::c_int as ::core::ffi::c_ushort as ::core::ffi::c_int
            != 0
        {
            *idx = (*path.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                - '0' as i32) as int32_t;
        } else {
            *__errno_location() = EINVAL;
            return 0 as ::core::ffi::c_int;
        }
    } else {
        if *path.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int == '0' as i32 {
            *__errno_location() = EINVAL;
            return 0 as ::core::ffi::c_int;
        }
        i = 0 as ::core::ffi::c_int;
        while i < len {
            if *(*__ctype_b_loc()).offset(
                *path.offset(i as isize) as ::core::ffi::c_uchar as ::core::ffi::c_int as isize
            ) as ::core::ffi::c_int
                & _ISdigit as ::core::ffi::c_int as ::core::ffi::c_ushort as ::core::ffi::c_int
                == 0
            {
                *__errno_location() = EINVAL;
                return 0 as ::core::ffi::c_int;
            }
            i += 1;
        }
        *idx = strtol(
            path,
            ::core::ptr::null_mut::<*mut ::core::ffi::c_char>(),
            10 as ::core::ffi::c_int,
        ) as int32_t;
        if *idx < 0 as int32_t {
            *__errno_location() = EINVAL;
            return 0 as ::core::ffi::c_int;
        }
    }
    len = json_object_array_length(jo) as ::core::ffi::c_int;
    if *idx >= len as int32_t {
        *__errno_location() = ENOENT;
        return 0 as ::core::ffi::c_int;
    }
    return 1 as ::core::ffi::c_int;
}```
"""
