transform = "CommentTransfer"
identifier = "json_escape_str"
model = "gemini-3-flash-preview"
response = """/// string escaping
unsafe extern "C" fn json_escape_str(
    mut pb: *mut printbuf,
    mut str: *const ::core::ffi::c_char,
    mut len: ::core::ffi::c_int,
    mut flags: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut pos: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut start_offset: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut c: ::core::ffi::c_uchar = 0;
    loop {
        let fresh0 = len;
        len = len - 1;
        if !(fresh0 != 0) {
            break;
        }
        c = *str.offset(pos as isize) as ::core::ffi::c_uchar;
        match c as ::core::ffi::c_int {
            8 | 10 | 13 | 9 | 12 | 34 | 92 | 47 => {
                if flags & crate::src::json_object::JSON_C_TO_STRING_NOSLASHESCAPE != 0
                    && c as ::core::ffi::c_int == '/' as i32
                {
                    pos += 1;
                } else {
                    if pos - start_offset > 0 as ::core::ffi::c_int {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            str.offset(start_offset as isize),
                            pos - start_offset,
                        );
                    }
                    if c as ::core::ffi::c_int == '\\u{8}' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\b\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\n' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\n\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\r' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\r\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\t' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\t\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\u{c}' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\f\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '"' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\\\"\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\\\' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\\\\\\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '/' as i32 {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            b"\\\\/\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    pos += 1;
                    start_offset = pos;
                }
            }
            _ => {
                if (c as ::core::ffi::c_int) < ' ' as i32 {
                    let mut sbuf: [::core::ffi::c_char; 7] = [0; 7];
                    if pos - start_offset > 0 as ::core::ffi::c_int {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            str.offset(start_offset as isize),
                            pos - start_offset,
                        );
                    }
                    snprintf(
                        &raw mut sbuf as *mut ::core::ffi::c_char,
                        ::core::mem::size_of::<[::core::ffi::c_char; 7]>() as size_t,
                        b"\\\\u00%c%c\\0" as *const u8 as *const ::core::ffi::c_char,
                        *json_hex_chars
                            .offset((c as ::core::ffi::c_int >> 4 as ::core::ffi::c_int) as isize)
                            as ::core::ffi::c_int,
                        *json_hex_chars
                            .offset((c as ::core::ffi::c_int & 0xf as ::core::ffi::c_int) as isize)
                            as ::core::ffi::c_int,
                    );
                    if (*pb).size - (*pb).bpos
                        > ::core::mem::size_of::<[::core::ffi::c_char; 7]>() as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int
                    {
                        memcpy(
                            (*pb).buf.offset((*pb).bpos as isize) as *mut ::core::ffi::c_void,
                            &raw mut sbuf as *mut ::core::ffi::c_char as *const ::core::ffi::c_void,
                            (::core::mem::size_of::<[::core::ffi::c_char; 7]>()
                                as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as size_t,
                        );
                        (*pb).bpos += ::core::mem::size_of::<[::core::ffi::c_char; 7]>()
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int;
                        *(*pb).buf.offset((*pb).bpos as isize) = '\\0' as i32 as ::core::ffi::c_char;
                    } else {
                        printbuf_memappend(
                            pb as *mut printbuf,
                            &raw mut sbuf as *mut ::core::ffi::c_char,
                            ::core::mem::size_of::<[::core::ffi::c_char; 7]>()
                                as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int,
                        );
                    }
                    pos += 1;
                    start_offset = pos;
                } else {
                    pos += 1;
                }
            }
        }
    }
    if pos - start_offset > 0 as ::core::ffi::c_int {
        printbuf_memappend(
            pb as *mut printbuf,
            str.offset(start_offset as isize),
            pos - start_offset,
        );
    }
    return 0 as ::core::ffi::c_int;
}"""

[[messages]]
role = "user"
content = """Transfer the comments from the following C function to the corresponding Rust function.
Do not add any comments that are not present in the C function.
Use Rust doc comment syntax (///) where appropriate (e.g., for function documentation).
Respond with the Rust function definition with the transferred comments; say nothing else.

C function:
```c
/* string escaping */

static int json_escape_str(struct printbuf *pb, const char *str, int len, int flags)
{
\tint pos = 0, start_offset = 0;
\tunsigned char c;
\twhile (len--)
\t{
\t\tc = str[pos];
\t\tswitch(c)
\t\t{
\t\tcase '\\b':
\t\tcase '\\n':
\t\tcase '\\r':
\t\tcase '\\t':
\t\tcase '\\f':
\t\tcase '"':
\t\tcase '\\\\':
\t\tcase '/':
\t\t\tif((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')
\t\t\t{
\t\t\t\tpos++;
\t\t\t\tbreak;
\t\t\t}

\t\t\tif(pos - start_offset > 0)
\t\t\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);

\t\t\tif(c == '\\b') printbuf_memappend(pb, "\\\\b", 2);
\t\t\telse if(c == '\\n') printbuf_memappend(pb, "\\\\n", 2);
\t\t\telse if(c == '\\r') printbuf_memappend(pb, "\\\\r", 2);
\t\t\telse if(c == '\\t') printbuf_memappend(pb, "\\\\t", 2);
\t\t\telse if(c == '\\f') printbuf_memappend(pb, "\\\\f", 2);
\t\t\telse if(c == '"') printbuf_memappend(pb, "\\\\\\"", 2);
\t\t\telse if(c == '\\\\') printbuf_memappend(pb, "\\\\\\\\", 2);
\t\t\telse if(c == '/') printbuf_memappend(pb, "\\\\/", 2);

\t\t\tstart_offset = ++pos;
\t\t\tbreak;
\t\tdefault:
\t\t\tif(c < ' ')
\t\t\t{
\t\t\t\tchar sbuf[7];
\t\t\t\tif(pos - start_offset > 0)
\t\t\t\t\tprintbuf_memappend(pb,
\t\t\t\t\t\t\t   str + start_offset,
\t\t\t\t\t\t\t   pos - start_offset);
\t\t\t\tsnprintf(sbuf, sizeof(sbuf),
\t\t\t\t\t "\\\\u00%c%c",
\t\t\t\t\t json_hex_chars[c >> 4],
\t\t\t\t\t json_hex_chars[c & 0xf]);
\t\t\t\tprintbuf_memappend_fast(pb, sbuf, (int) sizeof(sbuf) - 1);
\t\t\t\tstart_offset = ++pos;
\t\t\t} else
\t\t\t\tpos++;
\t\t}
\t}
\tif (pos - start_offset > 0)
\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);
\treturn 0;
}```

Rust function:
```rust
unsafe extern "C" fn json_escape_str(
    mut pb: *mut printbuf,
    mut str: *const ::core::ffi::c_char,
    mut len: ::core::ffi::c_int,
    mut flags: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut pos: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut start_offset: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut c: ::core::ffi::c_uchar = 0;
    loop {
        let fresh0 = len;
        len = len - 1;
        if !(fresh0 != 0) {
            break;
        }
        c = *str.offset(pos as isize) as ::core::ffi::c_uchar;
        match c as ::core::ffi::c_int {
            8 | 10 | 13 | 9 | 12 | 34 | 92 | 47 => {
                if flags & crate::src::json_object::JSON_C_TO_STRING_NOSLASHESCAPE != 0
                    && c as ::core::ffi::c_int == '/' as i32
                {
                    pos += 1;
                } else {
                    if pos - start_offset > 0 as ::core::ffi::c_int {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            str.offset(start_offset as isize),
                            pos - start_offset,
                        );
                    }
                    if c as ::core::ffi::c_int == '\\u{8}' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\b\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\n' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\n\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\r' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\r\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\t' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\t\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\u{c}' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\f\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '"' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\\\"\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '\\\\' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\\\\\\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    } else if c as ::core::ffi::c_int == '/' as i32 {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            b"\\\\/\\0" as *const u8 as *const ::core::ffi::c_char,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    pos += 1;
                    start_offset = pos;
                }
            }
            _ => {
                if (c as ::core::ffi::c_int) < ' ' as i32 {
                    let mut sbuf: [::core::ffi::c_char; 7] = [0; 7];
                    if pos - start_offset > 0 as ::core::ffi::c_int {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            str.offset(start_offset as isize),
                            pos - start_offset,
                        );
                    }
                    snprintf(
                        &raw mut sbuf as *mut ::core::ffi::c_char,
                        ::core::mem::size_of::<[::core::ffi::c_char; 7]>() as size_t,
                        b"\\\\u00%c%c\\0" as *const u8 as *const ::core::ffi::c_char,
                        *json_hex_chars
                            .offset((c as ::core::ffi::c_int >> 4 as ::core::ffi::c_int) as isize)
                            as ::core::ffi::c_int,
                        *json_hex_chars
                            .offset((c as ::core::ffi::c_int & 0xf as ::core::ffi::c_int) as isize)
                            as ::core::ffi::c_int,
                    );
                    if (*pb).size - (*pb).bpos
                        > ::core::mem::size_of::<[::core::ffi::c_char; 7]>() as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int
                    {
                        memcpy(
                            (*pb).buf.offset((*pb).bpos as isize) as *mut ::core::ffi::c_void,
                            &raw mut sbuf as *mut ::core::ffi::c_char as *const ::core::ffi::c_void,
                            (::core::mem::size_of::<[::core::ffi::c_char; 7]>()
                                as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as size_t,
                        );
                        (*pb).bpos += ::core::mem::size_of::<[::core::ffi::c_char; 7]>()
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int;
                        *(*pb).buf.offset((*pb).bpos as isize) = '\\0' as i32 as ::core::ffi::c_char;
                    } else {
                        printbuf_memappend(
                            
                            pb as *mut printbuf,
                            &raw mut sbuf as *mut ::core::ffi::c_char,
                            ::core::mem::size_of::<[::core::ffi::c_char; 7]>()
                                as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int,
                        );
                    }
                    pos += 1;
                    start_offset = pos;
                } else {
                    pos += 1;
                }
            }
        }
    }
    if pos - start_offset > 0 as ::core::ffi::c_int {
        printbuf_memappend(pb as *mut printbuf, str.offset(start_offset as isize), pos - start_offset);
    }
    return 0 as ::core::ffi::c_int;
}```
"""
