transform = "CommentTransfer"
identifier = "json_object_array_to_json_string"
model = "gemini-3-flash-preview"
response = """/// json_object_array
unsafe extern "C" fn json_object_array_to_json_string(
    mut jso: *mut json_object,
    mut pb: *mut printbuf,
    mut level: ::core::ffi::c_int,
    mut flags: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut had_children: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut ii: size_t = 0;
    printbuf_memappend(
        
        pb as *mut printbuf,
        b"[\\0" as *const u8 as *const ::core::ffi::c_char,
        (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize).wrapping_sub(1 as usize)
            as ::core::ffi::c_int,
    );
    if flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY != 0 {
        printbuf_memappend(
            
            pb as *mut printbuf,
            b"\\n\\0" as *const u8 as *const ::core::ffi::c_char,
            (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize).wrapping_sub(1 as usize)
                as ::core::ffi::c_int,
        );
    }
    ii = 0 as size_t;
    while ii < json_object_array_length(jso) {
        let mut val: *mut json_object = ::core::ptr::null_mut::<json_object>();
        if had_children != 0 {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b",\\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
            if flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY != 0 {
                printbuf_memappend(
                    
                    pb as *mut printbuf,
                    b"\\n\\0" as *const u8 as *const ::core::ffi::c_char,
                    (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                        .wrapping_sub(1 as usize) as ::core::ffi::c_int,
                );
            }
        }
        had_children = 1 as ::core::ffi::c_int;
        if flags & crate::src::json_object::JSON_C_TO_STRING_SPACED != 0 && flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY == 0 {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b" \\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
        }
        indent(pb, level + 1 as ::core::ffi::c_int, flags);
        val = json_object_array_get_idx(jso, ii);
        if val.is_null() {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b"null\\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 5]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
        } else if (*val)._to_json_string.expect("non-null function pointer")(
            val,
            pb,
            level + 1 as ::core::ffi::c_int,
            flags,
        ) < 0 as ::core::ffi::c_int
        {
            return -(1 as ::core::ffi::c_int);
        }
        ii = ii.wrapping_add(1);
    }
    if flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY != 0 {
        if had_children != 0 {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b"\\n\\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
        }
        indent(pb, level, flags);
    }
    if flags & crate::src::json_object::JSON_C_TO_STRING_SPACED != 0 && flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY == 0 {
        return printbuf_memappend(
            
            pb as *mut printbuf,
            b" ]\\0" as *const u8 as *const ::core::ffi::c_char,
            (::core::mem::size_of::<[::core::ffi::c_char; 3]>() as usize).wrapping_sub(1 as usize)
                as ::core::ffi::c_int,
        );
    }
    return printbuf_memappend(
        
        pb as *mut printbuf,
        b"]\\0" as *const u8 as *const ::core::ffi::c_char,
        (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize).wrapping_sub(1 as usize)
            as ::core::ffi::c_int,
    );
}"""

[[messages]]
role = "user"
content = """Transfer the comments from the following C function to the corresponding Rust function.
Do not add any comments that are not present in the C function.
Use Rust doc comment syntax (///) where appropriate (e.g., for function documentation).
Respond with the Rust function definition with the transferred comments; say nothing else.

C function:
```c
/* json_object_array */

static int json_object_array_to_json_string(struct json_object* jso,
                                            struct printbuf *pb,
                                            int level,
                                            int flags)
{
\tint had_children = 0;
\tsize_t ii;

\tprintbuf_strappend(pb, "[");
\tif (flags & JSON_C_TO_STRING_PRETTY)
\t\tprintbuf_strappend(pb, "\\n");
\tfor(ii=0; ii < json_object_array_length(jso); ii++)
\t{
\t\tstruct json_object *val;
\t\tif (had_children)
\t\t{
\t\t\tprintbuf_strappend(pb, ",");
\t\t\tif (flags & JSON_C_TO_STRING_PRETTY)
\t\t\t\tprintbuf_strappend(pb, "\\n");
\t\t}
\t\thad_children = 1;
\t\tif (flags & JSON_C_TO_STRING_SPACED && !(flags&JSON_C_TO_STRING_PRETTY))
\t\t\tprintbuf_strappend(pb, " ");
\t\tindent(pb, level + 1, flags);
\t\tval = json_object_array_get_idx(jso, ii);
\t\tif(val == NULL)
\t\t\tprintbuf_strappend(pb, "null");
\t\telse
\t\t\tif (val->_to_json_string(val, pb, level+1, flags) < 0)
\t\t\t\treturn -1;
\t}
\tif (flags & JSON_C_TO_STRING_PRETTY)
\t{
\t\tif (had_children)
\t\t\tprintbuf_strappend(pb, "\\n");
\t\tindent(pb,level,flags);
\t}

\tif (flags & JSON_C_TO_STRING_SPACED && !(flags&JSON_C_TO_STRING_PRETTY))
\t\treturn printbuf_strappend(pb, " ]");
\treturn printbuf_strappend(pb, "]");
}```

Rust function:
```rust
unsafe extern "C" fn json_object_array_to_json_string(
    mut jso: *mut json_object,
    mut pb: *mut printbuf,
    mut level: ::core::ffi::c_int,
    mut flags: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut had_children: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut ii: size_t = 0;
    printbuf_memappend(
        
        pb as *mut printbuf,
        b"[\\0" as *const u8 as *const ::core::ffi::c_char,
        (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize).wrapping_sub(1 as usize)
            as ::core::ffi::c_int,
    );
    if flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY != 0 {
        printbuf_memappend(
            
            pb as *mut printbuf,
            b"\\n\\0" as *const u8 as *const ::core::ffi::c_char,
            (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize).wrapping_sub(1 as usize)
                as ::core::ffi::c_int,
        );
    }
    ii = 0 as size_t;
    while ii < json_object_array_length(jso) {
        let mut val: *mut json_object = ::core::ptr::null_mut::<json_object>();
        if had_children != 0 {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b",\\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
            if flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY != 0 {
                printbuf_memappend(
                    
                    pb as *mut printbuf,
                    b"\\n\\0" as *const u8 as *const ::core::ffi::c_char,
                    (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                        .wrapping_sub(1 as usize) as ::core::ffi::c_int,
                );
            }
        }
        had_children = 1 as ::core::ffi::c_int;
        if flags & crate::src::json_object::JSON_C_TO_STRING_SPACED != 0 && flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY == 0 {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b" \\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
        }
        indent(pb, level + 1 as ::core::ffi::c_int, flags);
        val = json_object_array_get_idx(jso, ii);
        if val.is_null() {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b"null\\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 5]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
        } else if (*val)._to_json_string.expect("non-null function pointer")(
            val,
            pb,
            level + 1 as ::core::ffi::c_int,
            flags,
        ) < 0 as ::core::ffi::c_int
        {
            return -(1 as ::core::ffi::c_int);
        }
        ii = ii.wrapping_add(1);
    }
    if flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY != 0 {
        if had_children != 0 {
            printbuf_memappend(
                
                pb as *mut printbuf,
                b"\\n\\0" as *const u8 as *const ::core::ffi::c_char,
                (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize)
                    .wrapping_sub(1 as usize) as ::core::ffi::c_int,
            );
        }
        indent(pb, level, flags);
    }
    if flags & crate::src::json_object::JSON_C_TO_STRING_SPACED != 0 && flags & crate::src::json_object::JSON_C_TO_STRING_PRETTY == 0 {
        return printbuf_memappend(
            
            pb as *mut printbuf,
            b" ]\\0" as *const u8 as *const ::core::ffi::c_char,
            (::core::mem::size_of::<[::core::ffi::c_char; 3]>() as usize).wrapping_sub(1 as usize)
                as ::core::ffi::c_int,
        );
    }
    return printbuf_memappend(
        
        pb as *mut printbuf,
        b"]\\0" as *const u8 as *const ::core::ffi::c_char,
        (::core::mem::size_of::<[::core::ffi::c_char; 2]>() as usize).wrapping_sub(1 as usize)
            as ::core::ffi::c_int,
    );
}```
"""
