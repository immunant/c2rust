transform = "CommentTransfer"
identifier = "_json_c_strerror"
model = "gemini-3-flash-preview"
response = """#[no_mangle]
pub unsafe extern "C" fn _json_c_strerror(
    mut errno_in: ::core::ffi::c_int,
) -> *mut ::core::ffi::c_char {
    let mut start_idx: ::core::ffi::c_int = 0;
    let mut digbuf: [::core::ffi::c_char; 20] = [0; 20];
    let mut ii: ::core::ffi::c_int = 0;
    let mut jj: ::core::ffi::c_int = 0;
    if _json_c_strerror_enable == 0 {
        return strerror(errno_in);
    }

    // Avoid standard functions, so we don't need to include any
    // headers, or guess at signatures.
    ii = 0 as ::core::ffi::c_int;
    while !errno_list[ii as usize].errno_str.is_null() {
        let mut errno_str: *const ::core::ffi::c_char = errno_list[ii as usize].errno_str;
        if errno_list[ii as usize].errno_value != errno_in {
            ii += 1;
        } else {
            start_idx = (::core::mem::size_of::<[::core::ffi::c_char; 7]>() as usize)
                .wrapping_sub(1 as usize) as ::core::ffi::c_int;
            jj = 0 as ::core::ffi::c_int;
            while *errno_str.offset(jj as isize) as ::core::ffi::c_int != '\\0' as i32 {
                errno_buf[start_idx as usize] = *errno_str.offset(jj as isize);
                jj += 1;
                start_idx += 1;
            }
            errno_buf[start_idx as usize] = '\\0' as i32 as ::core::ffi::c_char;
            return &raw mut errno_buf as *mut ::core::ffi::c_char;
        }
    }

    // It's not one of the known errno values, return the numeric value.
    ii = 0 as ::core::ffi::c_int;
    while errno_in > 10 as ::core::ffi::c_int {
        digbuf[ii as usize] =
            ::core::mem::transmute::<[u8; 11], [::core::ffi::c_char; 11]>(*b"0123456789\\0")
                [(errno_in % 10 as ::core::ffi::c_int) as usize];
        errno_in /= 10 as ::core::ffi::c_int;
        ii += 1;
    }
    digbuf[ii as usize] =
        ::core::mem::transmute::<[u8; 11], [::core::ffi::c_char; 11]>(*b"0123456789\\0")
            [(errno_in % 10 as ::core::ffi::c_int) as usize];

    // Reverse the digits
    start_idx = (::core::mem::size_of::<[::core::ffi::c_char; 7]>() as usize)
        .wrapping_sub(1 as usize) as ::core::ffi::c_int;
    while ii >= 0 as ::core::ffi::c_int {
        errno_buf[start_idx as usize] = digbuf[ii as usize];
        ii -= 1;
        start_idx += 1;
    }
    return &raw mut errno_buf as *mut ::core::ffi::c_char;
}"""

[[messages]]
role = "user"
content = """Transfer the comments from the following C function to the corresponding Rust function.
Do not add any comments that are not present in the C function.
Use Rust doc comment syntax (///) where appropriate (e.g., for function documentation).
Respond with the Rust function definition with the transferred comments; say nothing else.

C function:
```c
char *_json_c_strerror(int errno_in)
{
\tint start_idx;
\tchar digbuf[20];
\tint ii, jj;

\tif (!_json_c_strerror_enable)
\t\treturn strerror(errno_in);

\t// Avoid standard functions, so we don't need to include any
\t// headers, or guess at signatures.

\tfor (ii = 0; errno_list[ii].errno_str != (char *)0; ii++)
\t{
\t\tconst char *errno_str = errno_list[ii].errno_str;
\t\tif (errno_list[ii].errno_value != errno_in)
\t\t\tcontinue;

\t\tfor (start_idx = sizeof(PREFIX) - 1, jj = 0; errno_str[jj] != '\\0'; jj++, start_idx++)
\t\t{
\t\t\terrno_buf[start_idx] = errno_str[jj];
\t\t}
\t\terrno_buf[start_idx] = '\\0';
\t\treturn errno_buf;
\t}

\t// It's not one of the known errno values, return the numeric value.
\tfor (ii = 0; errno_in > 10; errno_in /= 10, ii++)
\t{
\t\tdigbuf[ii] = "0123456789"[(errno_in % 10)];
\t}
\tdigbuf[ii] = "0123456789"[(errno_in % 10)];

\t// Reverse the digits
\tfor (start_idx = sizeof(PREFIX) - 1 ; ii >= 0; ii--, start_idx++)
\t{
\t\terrno_buf[start_idx] = digbuf[ii];
\t}
\treturn errno_buf;
}```

Rust function:
```rust
#[no_mangle]

pub unsafe extern "C" fn _json_c_strerror(
    mut errno_in: ::core::ffi::c_int,
) -> *mut ::core::ffi::c_char {
    let mut start_idx: ::core::ffi::c_int = 0;
    let mut digbuf: [::core::ffi::c_char; 20] = [0; 20];
    let mut ii: ::core::ffi::c_int = 0;
    let mut jj: ::core::ffi::c_int = 0;
    if _json_c_strerror_enable == 0 {
        return strerror(errno_in);
    }
    ii = 0 as ::core::ffi::c_int;
    while !errno_list[ii as usize].errno_str.is_null() {
        let mut errno_str: *const ::core::ffi::c_char = errno_list[ii as usize].errno_str;
        if errno_list[ii as usize].errno_value != errno_in {
            ii += 1;
        } else {
            start_idx = (::core::mem::size_of::<[::core::ffi::c_char; 7]>() as usize)
                .wrapping_sub(1 as usize) as ::core::ffi::c_int;
            jj = 0 as ::core::ffi::c_int;
            while *errno_str.offset(jj as isize) as ::core::ffi::c_int != '\\0' as i32 {
                errno_buf[start_idx as usize] = *errno_str.offset(jj as isize);
                jj += 1;
                start_idx += 1;
            }
            errno_buf[start_idx as usize] = '\\0' as i32 as ::core::ffi::c_char;
            return &raw mut errno_buf as *mut ::core::ffi::c_char;
        }
    }
    ii = 0 as ::core::ffi::c_int;
    while errno_in > 10 as ::core::ffi::c_int {
        digbuf[ii as usize] =
            ::core::mem::transmute::<[u8; 11], [::core::ffi::c_char; 11]>(*b"0123456789\\0")
                [(errno_in % 10 as ::core::ffi::c_int) as usize];
        errno_in /= 10 as ::core::ffi::c_int;
        ii += 1;
    }
    digbuf[ii as usize] =
        ::core::mem::transmute::<[u8; 11], [::core::ffi::c_char; 11]>(*b"0123456789\\0")
            [(errno_in % 10 as ::core::ffi::c_int) as usize];
    start_idx = (::core::mem::size_of::<[::core::ffi::c_char; 7]>() as usize)
        .wrapping_sub(1 as usize) as ::core::ffi::c_int;
    while ii >= 0 as ::core::ffi::c_int {
        errno_buf[start_idx as usize] = digbuf[ii as usize];
        ii -= 1;
        start_idx += 1;
    }
    return &raw mut errno_buf as *mut ::core::ffi::c_char;
}```
"""
