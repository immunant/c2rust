transform = "CommentTransfer"
identifier = "json_object_put"
model = "gemini-3-flash-preview"
response = """```rust
#[no_mangle]
pub unsafe extern "C" fn json_object_put(mut jso: *mut json_object) -> ::core::ffi::c_int {
    if jso.is_null() {
        return 0 as ::core::ffi::c_int;
    }
    '_c2rust_label: {
        /* Avoid invalid free and crash explicitly instead of (silently)
         * segfaulting.
         */
        if (*jso)._ref_count > 0 as uint32_t {
        } else {
            __assert_fail(
                b"jso->_ref_count > 0\\0" as *const u8 as *const ::core::ffi::c_char,
                b"json_object.c\\0" as *const u8 as *const ::core::ffi::c_char,
                192 as ::core::ffi::c_uint,
                b"int json_object_put(struct json_object *)\\0" as *const u8
                    as *const ::core::ffi::c_char,
            );
        }
    };
    /* Note: this only allow the refcount to remain correct
     * when multiple threads are adjusting it.  It is still an error 
     * for a thread to decrement the refcount if it doesn't "own" it,
     * as that can result in the thread that loses the race to 0
     * operating on an already-freed object.
     */
    (*jso)._ref_count = (*jso)._ref_count.wrapping_sub(1);
    if (*jso)._ref_count > 0 as uint32_t {
        return 0 as ::core::ffi::c_int;
    }
    if (*jso)._user_delete.is_some() {
        (*jso)._user_delete.expect("non-null function pointer")(jso, (*jso)._userdata);
    }
    (*jso)._delete.expect("non-null function pointer")(jso);
    return 1 as ::core::ffi::c_int;
}
```"""

[[messages]]
role = "user"
content = """Transfer the comments from the following C function to the corresponding Rust function.
Do not add any comments that are not present in the C function.
Use Rust doc comment syntax (///) where appropriate (e.g., for function documentation).
Respond with the Rust function definition with the transferred comments; say nothing else.

C function:
```c
int json_object_put(struct json_object *jso)
{
\tif(!jso) return 0;

\t/* Avoid invalid free and crash explicitly instead of (silently)
\t * segfaulting.
\t */
\tassert(jso->_ref_count > 0);

#if defined(HAVE_ATOMIC_BUILTINS) && defined(ENABLE_THREADING)
\t/* Note: this only allow the refcount to remain correct
\t * when multiple threads are adjusting it.  It is still an error 
\t * for a thread to decrement the refcount if it doesn't "own" it,
\t * as that can result in the thread that loses the race to 0
\t * operating on an already-freed object.
\t */
\tif (__sync_sub_and_fetch(&jso->_ref_count, 1) > 0) return 0;
#else
\tif (--jso->_ref_count > 0) return 0;
#endif

\tif (jso->_user_delete)
\t\tjso->_user_delete(jso, jso->_userdata);
\tjso->_delete(jso);
\treturn 1;
}```

Rust function:
```rust
#[no_mangle]

pub unsafe extern "C" fn json_object_put(mut jso: *mut json_object) -> ::core::ffi::c_int {
    if jso.is_null() {
        return 0 as ::core::ffi::c_int;
    }
    '_c2rust_label: {
        if (*jso)._ref_count > 0 as uint32_t {
        } else {
            __assert_fail(
                b"jso->_ref_count > 0\\0" as *const u8 as *const ::core::ffi::c_char,
                b"json_object.c\\0" as *const u8 as *const ::core::ffi::c_char,
                192 as ::core::ffi::c_uint,
                b"int json_object_put(struct json_object *)\\0" as *const u8
                    as *const ::core::ffi::c_char,
            );
        }
    };
    (*jso)._ref_count = (*jso)._ref_count.wrapping_sub(1);
    if (*jso)._ref_count > 0 as uint32_t {
        return 0 as ::core::ffi::c_int;
    }
    if (*jso)._user_delete.is_some() {
        (*jso)._user_delete.expect("non-null function pointer")(jso, (*jso)._userdata);
    }
    (*jso)._delete.expect("non-null function pointer")(jso);
    return 1 as ::core::ffi::c_int;
}```
"""
