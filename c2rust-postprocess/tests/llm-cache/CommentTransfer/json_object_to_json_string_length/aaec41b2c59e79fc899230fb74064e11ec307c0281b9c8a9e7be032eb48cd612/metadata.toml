transform = "CommentTransfer"
identifier = "json_object_to_json_string_length"
model = "gemini-3-pro-preview"
response = """```rust
/// extended conversion to string
#[no_mangle]
#[c2rust::src_loc = "323:1"]
pub unsafe extern "C" fn json_object_to_json_string_length(
    mut jso: *mut json_object,
    mut flags: ::core::ffi::c_int,
    mut length: *mut size_t,
) -> *const ::core::ffi::c_char {
    let mut r: *const ::core::ffi::c_char = ::core::ptr::null::<::core::ffi::c_char>();
    let mut s: size_t = 0 as size_t;
    if jso.is_null() {
        s = 4 as size_t;
        r = b"null\\0" as *const u8 as *const ::core::ffi::c_char;
    } else if !(*jso)._pb.is_null()
        || {
            (*jso)._pb = printbuf_new();
            !(*jso)._pb.is_null()
        }
    {
        printbuf_reset((*jso)._pb);
        if (*jso)
            ._to_json_string
            .expect(
                "non-null function pointer",
            )(jso, (*jso)._pb, 0 as ::core::ffi::c_int, flags) >= 0 as ::core::ffi::c_int
        {
            s = (*(*jso)._pb).bpos as size_t;
            r = (*(*jso)._pb).buf;
        }
    }
    if !length.is_null() {
        *length = s;
    }
    return r;
}
```"""

[[messages]]
role = "user"
content = """Transfer the comments from the following C function to the corresponding Rust function.
Do not add any comments that are not present in the C function.
Use Rust doc comment syntax (///) where appropriate (e.g., for function documentation).
Respond with the Rust function definition with the transferred comments.

The Rust must contain exactly the same comments as the C code did.
This must be true even if there are C comments in conditionally-compiled code
not present in the Rust, including comments on preprocessor directives.
In such cases, insert the C comment (only the comment, not any C code)
into the Rust where the Rust code should have been.
If any C comments are not inserted into the Rust, explain why.

C function:
```c
/* extended conversion to string */

const char* json_object_to_json_string_length(struct json_object *jso, int flags, size_t *length)
{
\tconst char *r = NULL;
\tsize_t s = 0;

\tif (!jso)
\t{
\t\ts = 4;
\t\tr = "null";
\t}
\telse if ((jso->_pb) || (jso->_pb = printbuf_new()))
\t{
\t\tprintbuf_reset(jso->_pb);

\t\tif(jso->_to_json_string(jso, jso->_pb, 0, flags) >= 0)
\t\t{
\t\t\ts = (size_t)jso->_pb->bpos;
\t\t\tr = jso->_pb->buf;
\t\t}
\t}

\tif (length)
\t\t*length = s;
\treturn r;
}```

Rust function:
```rust
#[no_mangle]
#[c2rust::src_loc = "323:1"]
pub unsafe extern "C" fn json_object_to_json_string_length(
    mut jso: *mut json_object,
    mut flags: ::core::ffi::c_int,
    mut length: *mut size_t,
) -> *const ::core::ffi::c_char {
    let mut r: *const ::core::ffi::c_char = ::core::ptr::null::<::core::ffi::c_char>();
    let mut s: size_t = 0 as size_t;
    if jso.is_null() {
        s = 4 as size_t;
        r = b"null\\0" as *const u8 as *const ::core::ffi::c_char;
    } else if !(*jso)._pb.is_null()
        || {
            (*jso)._pb = printbuf_new();
            !(*jso)._pb.is_null()
        }
    {
        printbuf_reset((*jso)._pb);
        if (*jso)
            ._to_json_string
            .expect(
                "non-null function pointer",
            )(jso, (*jso)._pb, 0 as ::core::ffi::c_int, flags) >= 0 as ::core::ffi::c_int
        {
            s = (*(*jso)._pb).bpos as size_t;
            r = (*(*jso)._pb).buf;
        }
    }
    if !length.is_null() {
        *length = s;
    }
    return r;
}```
"""
