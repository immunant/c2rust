import json
import logging
import subprocess
from collections.abc import Generator, Iterable
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import Any

import tree_sitter_rust as tsrust
from pygments import lex
from pygments.lexer import RegexLexer
from pygments.lexers.c_cpp import CLexer
from pygments.token import Comment
from tree_sitter import Language, Node, Parser

from postprocess.definitions.clang import (
    get_c_ast_as_json,
    get_functions_from_clang_ast,
    is_entry_from_c_file,
)
from postprocess.utils import get_tool_path


def get_c_sourcefile(compile_commands, rustfile: Path) -> Path | None:
    c_file_guesses = [rustfile.with_suffix(".c"), rustfile.with_suffix(".C")]

    files = [Path(d["file"]) for d in compile_commands]

    for guess in c_file_guesses:
        if guess in files:
            return guess

    return None


RUST_LANGUAGE = Language(tsrust.language())


def get_rust_function_spans(rustfile: Path) -> list[dict[str, Any]]:
    parser = Parser(RUST_LANGUAGE)

    try:
        source_bytes = rustfile.read_bytes()
    except OSError as exc:
        logging.error(f"Failed to read Rust file {rustfile}: {exc}")
        return []

    tree = parser.parse(source_bytes)

    functions = []

    for node in tree.root_node.children:
        if node.type == "function_item":
            name_node = node.child_by_field_name("name")
            func_name = source_bytes[
                name_node.start_byte :   # type: ignore
                name_node.end_byte  # type: ignore
            ].decode("utf-8")

            functions.append(
                {
                    "name": func_name,
                    "start_line": node.start_point[0] + 1,  # 0-indexed
                    "end_line": node.end_point[0] + 1,  # 0-indexed
                    "start_byte": node.start_byte,
                    "end_byte": node.end_byte,
                }
            )

    return functions


def get_c_function_spans(compile_commands: list[dict[str, Any]], c_file: Path):
    cmd = (c for c in compile_commands if c["file"] == str(c_file))
    entry = next(cmd, None)

    assert entry is not None, f"No compile command entry for {c_file}"

    c_fn_asts = get_functions_from_clang_ast(get_c_ast_as_json(entry))

    functions = []
    for fn in c_fn_asts:
        if not is_entry_from_c_file(fn, str(c_file)):
            continue

        loc = fn["loc"]
        if "line" in loc and "col" in loc:
            # usually, path to offset is: range -> begin -> offset
            # sometimes, likely due to the use of macros, path to offset is:
            # range -> begin -> expansionLoc -> offset
            if "offset" not in fn["range"]["begin"]:
                begin_line = fn["range"]["begin"]["expansionLoc"]["line"]
                begin_offset = fn["range"]["begin"]["expansionLoc"]["offset"]
            else:
                begin_line = fn["loc"]["line"]
                begin_offset = fn["range"]["begin"]["offset"]

            # TODO: are there cases where path to end offset/line differs?
            end_line = fn["range"]["end"]["line"]
            end_offset = fn["range"]["end"]["offset"]

            functions.append(
                {
                    "name": fn["name"],
                    "start_line": begin_line,
                    "start_byte": begin_offset,
                    "end_line": end_line,
                    "end_byte": end_offset,
                }
            )

    return functions


def get_function_span_pairs(
    compile_commands: list[dict[str, Any]], rust_file: Path
) -> list[tuple[dict[str, Any], dict[str, Any]]]:
    """Get pairs of Rust and C function spans for the given Rust file."""

    rust_fn_spans = get_rust_function_spans(rust_file)

    # drop synthetic main function generated by c2rust transpiler
    rust_fn_spans = filter(lambda fn: fn["name"] != "main", rust_fn_spans)
    c_file = get_c_sourcefile(compile_commands, rust_file)
    if not c_file:
        logging.info(f"No corresponding C source file found for {rust_file}")
        return []

    c_fn_spans = get_c_function_spans(compile_commands, c_file)
    c_fn_spans = {fn["name"]: fn for fn in c_fn_spans}

    pairs = []
    for rust_fn in rust_fn_spans:
        name = rust_fn["name"]
        assert name != "main"
        if name == "main_0":
            name = "main"

        if name in c_fn_spans:
            c_fn = c_fn_spans[name]
            c_fn["file"] = c_file
            rust_fn["file"] = rust_file
            pairs.append((rust_fn, c_fn))
        else:
            logging.warning(f"Rust function {name} has no matching C function")

    return pairs


def get_comment_text(comment: str) -> Generator[str]:
    """
    Get the lines of text of any C or Rust comment.
    Exclude things like leading ///, //, /*, *, **, etc. and trailing */.
    """
    comment = comment.strip()
    if comment.startswith("///"):
        yield comment.removeprefix("///").lstrip()
    elif comment.startswith("//"):
        yield comment.removeprefix("//").lstrip()
    elif comment.startswith("/*"):
        comment = comment.removeprefix("/*").removesuffix("*/").strip()
        for line in comment.splitlines():
            yield line.strip().lstrip("*/").lstrip()
    else:
        yield comment


def get_comments_text(comments: Iterable[str]) -> list[str]:
    """
    Get the lines of text of any C or Rust comment for many comments.
    Multi-line comments are split and flattened.
    """
    return [
        comment_line
        for comment in comments
        for comment_line in get_comment_text(comment)
        if comment_line
    ]


def get_c_comments(code: str) -> list[str]:
    """
    Extract comments from the given C code.
    Exclude the comment markers themselves.
    """
    return get_comments_text(get_comments(code, CLexer()))


def get_rust_comments(code: str) -> list[str]:
    """
    Extract comments from the given Rust code.
    Exclude the comment markers themselves.
    """
    parser = Parser(RUST_LANGUAGE)

    code_bytes = code.encode()
    tree = parser.parse(code_bytes)

    def walk(node: Node) -> Generator[str]:
        if node.type in {"line_comment", "block_comment"}:
            yield code_bytes[node.start_byte : node.end_byte].decode()
        for child in node.children:
            yield from walk(child)

    return get_comments_text(walk(tree.root_node))


def get_comments(code: str, lexer: RegexLexer) -> list[str]:
    comments = []
    for tok_type, tok_value in lex(code, lexer):
        if tok_type in Comment and tok_type != Comment.Preproc:
            # Keep exactly what appears, including delimiters (//, /* */)
            comments.append(tok_value)
    return comments


def get_rust_definitions(root_rust_source_file: Path) -> dict[str, str]:
    """
    Call ../tools/split_rust/target/release/split_rust rust_source_file_root and
    return the output as a dict mapping function identifiers to their definitions.
    """
    split_rust_path = get_tool_path("split_rust")

    # call split_rust tool with root_rust_source_file as argument
    result = subprocess.run(
        [split_rust_path, root_rust_source_file],
        capture_output=True,
        text=True,
        check=True,
        env={"RUST_BACKTRACE": "1"},
    )

    return json.loads(result.stdout)


def get_c_definitions(root_rust_source_file: Path) -> dict[str, str]:
    c_defs_json = root_rust_source_file.with_suffix(".c_decls.json")

    logging.debug(f"Loading C definitions from {c_defs_json}")
    try:
        return json.loads(c_defs_json.read_text())
    except OSError as e:
        e.add_note(f"C definitions JSON file not found: {c_defs_json}")
        raise e


def update_rust_definition(
    root_rust_source_file: Path,
    identifier: str,
    new_definition: str,
) -> None:
    """Update the Rust source file with the new definition."""
    merge_rust_path = get_tool_path("merge_rust")

    new_definition_json = {identifier: new_definition}

    with NamedTemporaryFile(mode="w+t") as temp_file:
        json.dump(new_definition_json, temp_file)
        temp_file.flush()

        args = [merge_rust_path, root_rust_source_file, temp_file.name]
        logging.debug(f"Running merge_rust with args: {args}")

        result = subprocess.run(
            args,
            text=True,
            capture_output=True,
            check=False,
            env={"RUST_BACKTRACE": "1"},
        )

        if result.returncode != 0:
            print(result.stdout)
            print(result.stderr)
            raise RuntimeError(f"merge_rust failed with exit code {result.returncode}")

    logging.info(f"Updated Rust definition of {identifier}")
