---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/arch-specific/vm_x86.x86_64.rs
input_file: c2rust-transpile/tests/snapshots/arch-specific/vm_x86.c
---
#![allow(
    dead_code,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
#![feature(asm, raw_ref_op)]
use ::core::arch::asm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vm_t {
    pub programStack: ::core::ffi::c_int,
    pub entryOfs: ::core::ffi::c_int,
    pub dataBase: *mut ::core::ffi::c_void,
    pub codeBase: *mut ::core::ffi::c_void,
    pub instructionPointers: *mut ::core::ffi::c_ulong,
}
pub type byte = ::core::ffi::c_uchar;
pub const MAX_VMMAIN_ARGS: ::core::ffi::c_int = 50 as ::core::ffi::c_int;
#[no_mangle]
pub unsafe extern "C" fn VM_CallCompiled(
    mut vm: *mut vm_t,
    mut args: *mut ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut stack: [byte; 271] = [0; 271];
    let mut entryPoint: *mut ::core::ffi::c_void = ::core::ptr::null_mut::<::core::ffi::c_void>();
    let mut programStack: ::core::ffi::c_int = 0;
    let mut stackOnEntry: ::core::ffi::c_int = 0;
    let mut image: *mut byte = ::core::ptr::null_mut::<byte>();
    let mut opStack: *mut ::core::ffi::c_int = ::core::ptr::null_mut::<::core::ffi::c_int>();
    let mut opStackOfs: ::core::ffi::c_int = 0;
    let mut arg: ::core::ffi::c_int = 0;
    let mut currentVM: *mut vm_t = vm;
    stackOnEntry = (*vm).programStack;
    programStack = stackOnEntry;
    image = (*vm).dataBase as *mut byte;
    programStack -= 8 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * MAX_VMMAIN_ARGS;
    arg = 0 as ::core::ffi::c_int;
    while arg < MAX_VMMAIN_ARGS {
        *(image.offset(
            (programStack + 8 as ::core::ffi::c_int + arg * 4 as ::core::ffi::c_int) as isize,
        ) as *mut byte as *mut ::core::ffi::c_int) = *args.offset(arg as isize);
        arg += 1;
    }
    *(image.offset((programStack + 4 as ::core::ffi::c_int) as isize) as *mut byte
        as *mut ::core::ffi::c_int) = 0 as ::core::ffi::c_int;
    *(image.offset(programStack as isize) as *mut byte as *mut ::core::ffi::c_int) =
        -(1 as ::core::ffi::c_int);
    entryPoint = (*vm).codeBase.offset((*vm).entryOfs as isize);
    opStack = (&raw mut stack as *mut byte as *mut ::core::ffi::c_int)
        .offset(16 as ::core::ffi::c_int as isize);
    *opStack = 0 as ::core::ffi::c_int;
    opStackOfs = 0 as ::core::ffi::c_int;
    asm!(
        "movq ({2}), %rax\n", "movq ({0}), %r8\n", "movq ({1}), %r9\n", "push %r15\n",
        "push %r14\n", "push %r13\n", "push %r12\n", "callq *%rax\n", "pop %r12\n",
        "pop %r13\n", "pop %r14\n", "pop %r15\n", "\n", "mov {restmp0:x}, %bx\n", in
        (reg) & (* vm).instructionPointers, in (reg) & (* vm).dataBase, in (reg) &
        entryPoint, restmp0 = inlateout(reg) opStackOfs, inlateout("di") opStack,
        inlateout("si") programStack, out("rax") _, out("rcx") _, out("rdx") _, out("r8")
        _, out("r9") _, out("r10") _, out("r11") _, options(att_syntax)
    );
    if opStackOfs != 1 as ::core::ffi::c_int
        || *opStack as ::core::ffi::c_uint != 0xdeadbeef as ::core::ffi::c_uint
    {
        return 0 as ::core::ffi::c_int;
    }
    if programStack
        != stackOnEntry - (8 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * MAX_VMMAIN_ARGS)
    {
        return 0 as ::core::ffi::c_int;
    }
    (*vm).programStack = stackOnEntry;
    return *opStack.offset(opStackOfs as isize);
}
