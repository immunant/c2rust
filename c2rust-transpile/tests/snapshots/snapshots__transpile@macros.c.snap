---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/macros.rs
input_file: c2rust-transpile/tests/snapshots/macros.c
---
#![allow(
    dead_code,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
#![feature(raw_ref_op)]
extern "C" {
    fn extern_fn() -> ::core::ffi::c_int;
}
pub type uintptr_t = usize;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct S {
    pub i: ::core::ffi::c_int,
}
pub type U64 = ::core::ffi::c_ulonglong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fn_ptrs {
    pub v: *mut ::core::ffi::c_void,
    pub fn1: Option<unsafe extern "C" fn() -> ::core::ffi::c_int>,
    pub fn2: Option<unsafe extern "C" fn(::core::ffi::c_int) -> ::core::ffi::c_int>,
}
pub type zstd_platform_dependent_type = ::core::ffi::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ntlmdata {
    pub target_info_len: ::core::ffi::c_uint,
}
pub const true_0: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
pub const UINTPTR_MAX: ::core::ffi::c_ulong = 18446744073709551615 as ::core::ffi::c_ulong;
pub const LITERAL_INT: ::core::ffi::c_int = 0xffff as ::core::ffi::c_int;
pub const LITERAL_BOOL: ::core::ffi::c_int = true_0;
pub const LITERAL_FLOAT: ::core::ffi::c_double = 3.14f64;
pub const LITERAL_CHAR: ::core::ffi::c_int = 'x' as i32;
pub const LITERAL_STR: [::core::ffi::c_char; 6] =
    unsafe { ::core::mem::transmute::<[u8; 6], [::core::ffi::c_char; 6]>(*b"hello\0") };
pub const LITERAL_STRUCT: S = {
    let mut init = S {
        i: 5 as ::core::ffi::c_int,
    };
    init
};
pub const NESTED_INT: ::core::ffi::c_int = LITERAL_INT;
pub const NESTED_BOOL: ::core::ffi::c_int = LITERAL_BOOL;
pub const NESTED_FLOAT: ::core::ffi::c_double = LITERAL_FLOAT;
pub const NESTED_CHAR: ::core::ffi::c_int = LITERAL_CHAR;
pub const NESTED_STR: [::core::ffi::c_char; 6] = LITERAL_STR;
pub const NESTED_STRUCT: S = LITERAL_STRUCT;
pub const PARENS: ::core::ffi::c_int = NESTED_INT * (LITERAL_CHAR + true_0);
pub const PTR_ARITHMETIC: *const ::core::ffi::c_char = unsafe {
    LITERAL_STR
        .as_ptr()
        .offset(5 as ::core::ffi::c_int as isize)
        .offset(-(3 as ::core::ffi::c_int as isize))
};
pub const WIDENING_CAST: ::core::ffi::c_ulonglong = LITERAL_INT as ::core::ffi::c_ulonglong;
pub const CONVERSION_CAST: ::core::ffi::c_double = LITERAL_INT as ::core::ffi::c_double;
#[no_mangle]
pub unsafe extern "C" fn local_muts() {
    let mut literal_int: ::core::ffi::c_int = LITERAL_INT;
    let mut literal_bool: bool = LITERAL_BOOL != 0;
    let mut literal_float: ::core::ffi::c_float = LITERAL_FLOAT as ::core::ffi::c_float;
    let mut literal_char: ::core::ffi::c_char = LITERAL_CHAR as ::core::ffi::c_char;
    let mut literal_str_ptr: *const ::core::ffi::c_char = LITERAL_STR.as_ptr();
    let mut literal_str: [::core::ffi::c_char; 6] = LITERAL_STR;
    let mut literal_array: [::core::ffi::c_int; 3] = [
        1 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        3 as ::core::ffi::c_int,
    ];
    let mut literal_struct: S = LITERAL_STRUCT;
    let mut nested_int: ::core::ffi::c_int = NESTED_INT;
    let mut nested_bool: bool = NESTED_BOOL != 0;
    let mut nested_float: ::core::ffi::c_float = NESTED_FLOAT as ::core::ffi::c_float;
    let mut nested_char: ::core::ffi::c_char = NESTED_CHAR as ::core::ffi::c_char;
    let mut nested_str_ptr: *const ::core::ffi::c_char = NESTED_STR.as_ptr();
    let mut nested_str: [::core::ffi::c_char; 6] = NESTED_STR;
    let mut nested_array: [::core::ffi::c_int; 3] = [
        1 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        3 as ::core::ffi::c_int,
    ];
    let mut nested_struct: S = NESTED_STRUCT;
    let mut int_arithmetic: ::core::ffi::c_int = NESTED_INT + LITERAL_INT + 1 as ::core::ffi::c_int;
    let mut mixed_arithmetic: ::core::ffi::c_float = (LITERAL_INT as ::core::ffi::c_double
        + NESTED_FLOAT * LITERAL_CHAR as ::core::ffi::c_double
        - true_0 as ::core::ffi::c_double)
        as ::core::ffi::c_float;
    let mut parens: ::core::ffi::c_int = PARENS;
    let mut ptr_arithmetic: *const ::core::ffi::c_char = PTR_ARITHMETIC;
    let mut widening_cast: ::core::ffi::c_ulonglong = WIDENING_CAST;
    let mut narrowing_cast: ::core::ffi::c_char = LITERAL_INT as ::core::ffi::c_char;
    let mut conversion_cast: ::core::ffi::c_double = CONVERSION_CAST;
    let mut indexing: ::core::ffi::c_char =
        NESTED_STR[LITERAL_FLOAT as ::core::ffi::c_int as usize];
    let mut str_concatenation_ptr: *const ::core::ffi::c_char =
        b"hello hello world\0" as *const u8 as *const ::core::ffi::c_char;
    let mut str_concatenation: [::core::ffi::c_char; 18] =
        ::core::mem::transmute::<[u8; 18], [::core::ffi::c_char; 18]>(*b"hello hello world\0");
    let mut builtin: ::core::ffi::c_int =
        (LITERAL_INT as ::core::ffi::c_uint).leading_zeros() as i32;
    let mut ref_indexing: *const ::core::ffi::c_char = &raw const *NESTED_STR
        .as_ptr()
        .offset(LITERAL_FLOAT as ::core::ffi::c_int as isize);
    let mut ref_struct: *const S = &mut LITERAL_STRUCT as *mut S;
    let mut ternary: ::core::ffi::c_int = if LITERAL_BOOL != 0 {
        1 as ::core::ffi::c_int
    } else {
        2 as ::core::ffi::c_int
    };
    let mut member: ::core::ffi::c_int = LITERAL_STRUCT.i;
    let mut stmt_expr: ::core::ffi::c_float = ({
        let mut builtin_0: ::core::ffi::c_int =
            (LITERAL_INT as ::core::ffi::c_uint).leading_zeros() as i32;
        let mut indexing_0: ::core::ffi::c_char =
            NESTED_STR[LITERAL_FLOAT as ::core::ffi::c_int as usize];
        let mut mixed: ::core::ffi::c_float = (LITERAL_INT as ::core::ffi::c_double
            + NESTED_FLOAT * LITERAL_CHAR as ::core::ffi::c_double
            - true_0 as ::core::ffi::c_double)
            as ::core::ffi::c_float;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < builtin_0 {
            mixed += indexing_0 as ::core::ffi::c_float;
            i += 1;
        }
        mixed
    });
}
#[no_mangle]
pub unsafe extern "C" fn local_consts() {
    let literal_int: ::core::ffi::c_int = LITERAL_INT;
    let literal_bool: bool = LITERAL_BOOL != 0;
    let literal_float: ::core::ffi::c_float = LITERAL_FLOAT as ::core::ffi::c_float;
    let literal_char: ::core::ffi::c_char = LITERAL_CHAR as ::core::ffi::c_char;
    let literal_str_ptr: *const ::core::ffi::c_char = LITERAL_STR.as_ptr();
    let literal_str: [::core::ffi::c_char; 6] = LITERAL_STR;
    let literal_array: [::core::ffi::c_int; 3] = [
        1 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        3 as ::core::ffi::c_int,
    ];
    let literal_struct: S = LITERAL_STRUCT;
    let nested_int: ::core::ffi::c_int = NESTED_INT;
    let nested_bool: bool = NESTED_BOOL != 0;
    let nested_float: ::core::ffi::c_float = NESTED_FLOAT as ::core::ffi::c_float;
    let nested_char: ::core::ffi::c_char = NESTED_CHAR as ::core::ffi::c_char;
    let nested_str_ptr: *const ::core::ffi::c_char = NESTED_STR.as_ptr();
    let nested_str: [::core::ffi::c_char; 6] = NESTED_STR;
    let nested_array: [::core::ffi::c_int; 3] = [
        1 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        3 as ::core::ffi::c_int,
    ];
    let nested_struct: S = NESTED_STRUCT;
    let int_arithmetic: ::core::ffi::c_int = NESTED_INT + LITERAL_INT + 1 as ::core::ffi::c_int;
    let mixed_arithmetic: ::core::ffi::c_float = (LITERAL_INT as ::core::ffi::c_double
        + NESTED_FLOAT * LITERAL_CHAR as ::core::ffi::c_double
        - true_0 as ::core::ffi::c_double)
        as ::core::ffi::c_float;
    let parens: ::core::ffi::c_int = PARENS;
    let ptr_arithmetic: *const ::core::ffi::c_char = PTR_ARITHMETIC;
    let widening_cast: ::core::ffi::c_ulonglong = WIDENING_CAST;
    let narrowing_cast: ::core::ffi::c_char = LITERAL_INT as ::core::ffi::c_char;
    let conversion_cast: ::core::ffi::c_double = CONVERSION_CAST;
    let indexing: ::core::ffi::c_char = NESTED_STR[LITERAL_FLOAT as ::core::ffi::c_int as usize];
    let str_concatenation_ptr: *const ::core::ffi::c_char =
        b"hello hello world\0" as *const u8 as *const ::core::ffi::c_char;
    let str_concatenation: [::core::ffi::c_char; 18] =
        ::core::mem::transmute::<[u8; 18], [::core::ffi::c_char; 18]>(*b"hello hello world\0");
    let builtin: ::core::ffi::c_int = (LITERAL_INT as ::core::ffi::c_uint).leading_zeros() as i32;
    let ref_indexing: *const ::core::ffi::c_char = &raw const *NESTED_STR
        .as_ptr()
        .offset(LITERAL_FLOAT as ::core::ffi::c_int as isize);
    let ref_struct: *const S = &mut LITERAL_STRUCT as *mut S;
    let ternary: ::core::ffi::c_int = if LITERAL_BOOL != 0 {
        1 as ::core::ffi::c_int
    } else {
        2 as ::core::ffi::c_int
    };
    let member: ::core::ffi::c_int = LITERAL_STRUCT.i;
    let stmt_expr: ::core::ffi::c_float = ({
        let mut builtin_0: ::core::ffi::c_int =
            (LITERAL_INT as ::core::ffi::c_uint).leading_zeros() as i32;
        let mut indexing_0: ::core::ffi::c_char =
            NESTED_STR[LITERAL_FLOAT as ::core::ffi::c_int as usize];
        let mut mixed: ::core::ffi::c_float = (LITERAL_INT as ::core::ffi::c_double
            + NESTED_FLOAT * LITERAL_CHAR as ::core::ffi::c_double
            - true_0 as ::core::ffi::c_double)
            as ::core::ffi::c_float;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < builtin_0 {
            mixed += indexing_0 as ::core::ffi::c_float;
            i += 1;
        }
        mixed
    });
}
static mut global_static_const_literal_int: ::core::ffi::c_int = LITERAL_INT;
static mut global_static_const_literal_bool: bool = LITERAL_BOOL != 0;
static mut global_static_const_literal_float: ::core::ffi::c_float =
    LITERAL_FLOAT as ::core::ffi::c_float;
static mut global_static_const_literal_char: ::core::ffi::c_char =
    LITERAL_CHAR as ::core::ffi::c_char;
static mut global_static_const_literal_str_ptr: *const ::core::ffi::c_char = LITERAL_STR.as_ptr();
static mut global_static_const_literal_str: [::core::ffi::c_char; 6] = LITERAL_STR;
static mut global_static_const_literal_array: [::core::ffi::c_int; 3] = [
    1 as ::core::ffi::c_int,
    2 as ::core::ffi::c_int,
    3 as ::core::ffi::c_int,
];
static mut global_static_const_literal_struct: S = LITERAL_STRUCT;
static mut global_static_const_nested_int: ::core::ffi::c_int = NESTED_INT;
static mut global_static_const_nested_bool: bool = NESTED_BOOL != 0;
static mut global_static_const_nested_float: ::core::ffi::c_float =
    NESTED_FLOAT as ::core::ffi::c_float;
static mut global_static_const_nested_char: ::core::ffi::c_char =
    NESTED_CHAR as ::core::ffi::c_char;
static mut global_static_const_nested_str_ptr: *const ::core::ffi::c_char = NESTED_STR.as_ptr();
static mut global_static_const_nested_str: [::core::ffi::c_char; 6] = NESTED_STR;
static mut global_static_const_nested_array: [::core::ffi::c_int; 3] = [
    1 as ::core::ffi::c_int,
    2 as ::core::ffi::c_int,
    3 as ::core::ffi::c_int,
];
static mut global_static_const_nested_struct: S = NESTED_STRUCT;
static mut global_static_const_int_arithmetic: ::core::ffi::c_int =
    NESTED_INT + LITERAL_INT + 1 as ::core::ffi::c_int;
static mut global_static_const_mixed_arithmetic: ::core::ffi::c_float =
    (LITERAL_INT as ::core::ffi::c_double + NESTED_FLOAT * LITERAL_CHAR as ::core::ffi::c_double
        - true_0 as ::core::ffi::c_double) as ::core::ffi::c_float;
static mut global_static_const_parens: ::core::ffi::c_int = PARENS;
static mut global_static_const_ptr_arithmetic: *const ::core::ffi::c_char =
    0 as *const ::core::ffi::c_char;
static mut global_static_const_widening_cast: ::core::ffi::c_ulonglong = WIDENING_CAST;
static mut global_static_const_narrowing_cast: ::core::ffi::c_char =
    LITERAL_INT as ::core::ffi::c_char;
static mut global_static_const_conversion_cast: ::core::ffi::c_double = CONVERSION_CAST;
static mut global_static_const_indexing: ::core::ffi::c_char = 0;
static mut global_static_const_str_concatenation_ptr: *const ::core::ffi::c_char =
    b"hello hello world\0" as *const u8 as *const ::core::ffi::c_char;
static mut global_static_const_str_concatenation: [::core::ffi::c_char; 18] = unsafe {
    ::core::mem::transmute::<[u8; 18], [::core::ffi::c_char; 18]>(*b"hello hello world\0")
};
static mut global_static_const_builtin: ::core::ffi::c_int =
    (LITERAL_INT as ::core::ffi::c_uint).leading_zeros() as i32;
static mut global_static_const_ref_indexing: *const ::core::ffi::c_char =
    0 as *const ::core::ffi::c_char;
static mut global_static_const_ref_struct: *const S = &LITERAL_STRUCT as *const S as *mut S;
static mut global_static_const_ternary: ::core::ffi::c_int = 0;
static mut global_static_const_member: ::core::ffi::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn global_static_consts() {}
#[no_mangle]
pub static mut global_const_literal_int: ::core::ffi::c_int = LITERAL_INT;
#[no_mangle]
pub static mut global_const_literal_bool: bool = LITERAL_BOOL != 0;
#[no_mangle]
pub static mut global_const_literal_float: ::core::ffi::c_float =
    LITERAL_FLOAT as ::core::ffi::c_float;
#[no_mangle]
pub static mut global_const_literal_char: ::core::ffi::c_char = LITERAL_CHAR as ::core::ffi::c_char;
#[no_mangle]
pub static mut global_const_literal_str_ptr: *const ::core::ffi::c_char = LITERAL_STR.as_ptr();
#[no_mangle]
pub static mut global_const_literal_str: [::core::ffi::c_char; 6] = LITERAL_STR;
#[no_mangle]
pub static mut global_const_literal_array: [::core::ffi::c_int; 3] = [
    1 as ::core::ffi::c_int,
    2 as ::core::ffi::c_int,
    3 as ::core::ffi::c_int,
];
#[no_mangle]
pub static mut global_const_literal_struct: S = LITERAL_STRUCT;
#[no_mangle]
pub static mut global_const_nested_int: ::core::ffi::c_int = NESTED_INT;
#[no_mangle]
pub static mut global_const_nested_bool: bool = NESTED_BOOL != 0;
#[no_mangle]
pub static mut global_const_nested_float: ::core::ffi::c_float =
    NESTED_FLOAT as ::core::ffi::c_float;
#[no_mangle]
pub static mut global_const_nested_char: ::core::ffi::c_char = NESTED_CHAR as ::core::ffi::c_char;
#[no_mangle]
pub static mut global_const_nested_str_ptr: *const ::core::ffi::c_char = NESTED_STR.as_ptr();
#[no_mangle]
pub static mut global_const_nested_str: [::core::ffi::c_char; 6] = NESTED_STR;
#[no_mangle]
pub static mut global_const_nested_array: [::core::ffi::c_int; 3] = [
    1 as ::core::ffi::c_int,
    2 as ::core::ffi::c_int,
    3 as ::core::ffi::c_int,
];
#[no_mangle]
pub static mut global_const_nested_struct: S = NESTED_STRUCT;
#[no_mangle]
pub static mut global_const_int_arithmetic: ::core::ffi::c_int =
    NESTED_INT + LITERAL_INT + 1 as ::core::ffi::c_int;
#[no_mangle]
pub static mut global_const_mixed_arithmetic: ::core::ffi::c_float =
    (LITERAL_INT as ::core::ffi::c_double + NESTED_FLOAT * LITERAL_CHAR as ::core::ffi::c_double
        - true_0 as ::core::ffi::c_double) as ::core::ffi::c_float;
#[no_mangle]
pub static mut global_const_parens: ::core::ffi::c_int = PARENS;
#[no_mangle]
pub static mut global_const_ptr_arithmetic: *const ::core::ffi::c_char =
    0 as *const ::core::ffi::c_char;
#[no_mangle]
pub static mut global_const_widening_cast: ::core::ffi::c_ulonglong = WIDENING_CAST;
#[no_mangle]
pub static mut global_const_narrowing_cast: ::core::ffi::c_char =
    LITERAL_INT as ::core::ffi::c_char;
#[no_mangle]
pub static mut global_const_conversion_cast: ::core::ffi::c_double = CONVERSION_CAST;
#[no_mangle]
pub static mut global_const_indexing: ::core::ffi::c_char = 0;
#[no_mangle]
pub static mut global_const_str_concatenation_ptr: *const ::core::ffi::c_char =
    b"hello hello world\0" as *const u8 as *const ::core::ffi::c_char;
#[no_mangle]
pub static mut global_const_str_concatenation: [::core::ffi::c_char; 18] = unsafe {
    ::core::mem::transmute::<[u8; 18], [::core::ffi::c_char; 18]>(*b"hello hello world\0")
};
#[no_mangle]
pub static mut global_const_builtin: ::core::ffi::c_int =
    (LITERAL_INT as ::core::ffi::c_uint).leading_zeros() as i32;
#[no_mangle]
pub static mut global_const_ref_indexing: *const ::core::ffi::c_char =
    0 as *const ::core::ffi::c_char;
#[no_mangle]
pub static mut global_const_ref_struct: *const S = &LITERAL_STRUCT as *const S as *mut S;
#[no_mangle]
pub static mut global_const_ternary: ::core::ffi::c_int = 0;
#[no_mangle]
pub static mut global_const_member: ::core::ffi::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn test_fn_macro(mut x: ::core::ffi::c_int) -> ::core::ffi::c_int {
    return x * x;
}
pub const TEST_CONST1: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
pub const TEST_NESTED: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
pub const TEST_CONST2: ::core::ffi::c_int = TEST_NESTED;
pub const TEST_PARENS: ::core::ffi::c_int =
    (TEST_CONST2 + 1 as ::core::ffi::c_int) * 3 as ::core::ffi::c_int;
#[no_mangle]
pub unsafe extern "C" fn reference_define() -> ::core::ffi::c_int {
    let mut x: ::core::ffi::c_int = TEST_CONST1;
    x += TEST_CONST2;
    if (3 as ::core::ffi::c_int) < TEST_PARENS {
        x += TEST_PARENS;
    }
    return x;
}
#[no_mangle]
pub static mut fns: fn_ptrs = {
    let mut init = fn_ptrs {
        v: 0 as *const ::core::ffi::c_void as *mut ::core::ffi::c_void,
        fn1: None,
        fn2: None,
    };
    init
};
#[no_mangle]
pub static mut p: *const fn_ptrs = unsafe { &raw const fns };
pub const ZSTD_WINDOWLOG_MAX_32: ::core::ffi::c_int = 30 as ::core::ffi::c_int;
pub const ZSTD_WINDOWLOG_MAX_64: ::core::ffi::c_int = 31 as ::core::ffi::c_int;
#[no_mangle]
pub unsafe extern "C" fn test_zstd() -> U64 {
    return (if ::core::mem::size_of::<zstd_platform_dependent_type>() as usize == 4 as usize {
        ZSTD_WINDOWLOG_MAX_32
    } else {
        ZSTD_WINDOWLOG_MAX_64
    }) as U64;
}
#[no_mangle]
pub unsafe extern "C" fn stmt_expr_inc() -> ::core::ffi::c_int {
    let mut a: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut b: *mut ::core::ffi::c_int = &raw mut a;
    ({
        *b += 1;
        *b;
        *b
    });
    return ({
        *b += 1;
        *b
    });
}
#[no_mangle]
pub unsafe extern "C" fn test_switch(mut x: ::core::ffi::c_int) -> ::core::ffi::c_int {
    match x {
        TEST_CONST1 => return 10 as ::core::ffi::c_int,
        TEST_NESTED => return 20 as ::core::ffi::c_int,
        _ => {}
    }
    return 0 as ::core::ffi::c_int;
}
pub const silk_int16_MIN: ::core::ffi::c_short =
    0x8000 as ::core::ffi::c_int as ::core::ffi::c_short;
#[no_mangle]
pub unsafe extern "C" fn test_silk_int16_MIN() -> ::core::ffi::c_int {
    let mut _null: ::core::ffi::c_char =
        ::core::mem::transmute::<[u8; 1], [::core::ffi::c_char; 1]>(*b"\0")
            [(silk_int16_MIN as ::core::ffi::c_int + 0x8000 as ::core::ffi::c_int) as usize];
    return silk_int16_MIN as ::core::ffi::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn use_extern_value() -> ::core::ffi::c_int {
    return extern_fn();
}
#[no_mangle]
pub unsafe extern "C" fn local_fn() -> ::core::ffi::c_int {
    return 1234 as ::core::ffi::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn use_local_value() -> ::core::ffi::c_int {
    return local_fn();
}
#[no_mangle]
pub unsafe extern "C" fn use_portable_type(mut len: uintptr_t) -> bool {
    return len <= (UINTPTR_MAX as uintptr_t).wrapping_div(2 as uintptr_t);
}
#[no_mangle]
pub unsafe extern "C" fn ntlm_v2_blob_len(mut ntlm: *mut ntlmdata) -> ::core::ffi::c_uint {
    return ((44 as ::core::ffi::c_int - 16 as ::core::ffi::c_int) as ::core::ffi::c_uint)
        .wrapping_add((*ntlm).target_info_len)
        .wrapping_add(4 as ::core::ffi::c_uint);
}
#[no_mangle]
pub unsafe extern "C" fn late_init_var() -> ::core::ffi::c_int {
    return ({
        let mut i: ::core::ffi::c_int = 0;
        i = 1 as ::core::ffi::c_int;
        i
    });
}
unsafe extern "C" fn run_static_initializers() {
    global_static_const_ptr_arithmetic = PTR_ARITHMETIC;
    global_static_const_indexing = NESTED_STR[LITERAL_FLOAT as ::core::ffi::c_int as usize];
    global_static_const_ref_indexing = &raw const *NESTED_STR
        .as_ptr()
        .offset(LITERAL_FLOAT as ::core::ffi::c_int as isize);
    global_static_const_ternary = if LITERAL_BOOL != 0 {
        1 as ::core::ffi::c_int
    } else {
        2 as ::core::ffi::c_int
    };
    global_static_const_member = LITERAL_STRUCT.i;
    global_const_ptr_arithmetic = PTR_ARITHMETIC;
    global_const_indexing = NESTED_STR[LITERAL_FLOAT as ::core::ffi::c_int as usize];
    global_const_ref_indexing = &raw const *NESTED_STR
        .as_ptr()
        .offset(LITERAL_FLOAT as ::core::ffi::c_int as isize);
    global_const_ternary = if LITERAL_BOOL != 0 {
        1 as ::core::ffi::c_int
    } else {
        2 as ::core::ffi::c_int
    };
    global_const_member = LITERAL_STRUCT.i;
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
