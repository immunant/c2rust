---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/os-specific/macros.macos.rs
input_file: c2rust-transpile/tests/snapshots/os-specific/macros.c
---
#![allow(
    dead_code,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
extern "C" {
    fn __error() -> *mut ::core::ffi::c_int;
    fn memcpy(
        __dst: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: size_t,
    ) -> *mut ::core::ffi::c_void;
}
pub type __darwin_size_t = usize;
pub type size_t = __darwin_size_t;
#[no_mangle]
pub unsafe extern "C" fn errno_is_error() -> bool {
    return *__error() != 0 as ::core::ffi::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn size_of_const() -> ::core::ffi::c_int {
    let mut a: [::core::ffi::c_int; 10] = [0; 10];
    return SIZE as ::core::ffi::c_int;
}
pub const SIZE: usize = ::core::mem::size_of::<[::core::ffi::c_int; 10]>();
pub const POS: [::core::ffi::c_char; 3] =
    unsafe { ::core::mem::transmute::<[u8; 3], [::core::ffi::c_char; 3]>(*b"\"]\0") };
#[no_mangle]
pub unsafe extern "C" fn memcpy_str_literal(mut out: *mut ::core::ffi::c_char) {
    memcpy(
        out as *mut ::core::ffi::c_void,
        POS.as_ptr() as *const ::core::ffi::c_void,
        (::core::mem::size_of::<[::core::ffi::c_char; 3]>() as size_t)
            .wrapping_div(::core::mem::size_of::<::core::ffi::c_char>() as size_t)
            .wrapping_sub(1 as size_t)
            .wrapping_add(1 as size_t)
            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_char>() as size_t),
    );
}
