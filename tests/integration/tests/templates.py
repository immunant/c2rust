import os
from pathlib import Path
import stat
from collections.abc import Mapping
from typing import Any, Generator

from tests.util import *
from jinja2 import Template

TRANSPILE_SH: str = r"""#!/usr/bin/env bash
# this file was autogenerated by templates.py
set -e; set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
LOG_FILE="$SCRIPT_DIR/$(basename "$0")".log

RUSTFLAGS="-Awarnings {{extra_rustflags}}" \
RUST_BACKTRACE=1 \
c2rust transpile \
    --c2rust-dir "${C2RUST_DIR}" \
    --emit-c-decl-map \
    --output-dir "$SCRIPT_DIR/repo" {{binary}} \
    {{tflags}} ${EXTRA_TFLAGS:---overwrite-existing} \
    compile_commands.json \
    -- {{cflags}} ${EXTRA_CFLAGS:--w} \
     2>&1 | tee "$LOG_FILE"

for build_file in build.rs Cargo.toml
do
    if [[ -f "$SCRIPT_DIR/$build_file" ]]; then
        cp "$SCRIPT_DIR/$build_file" "$SCRIPT_DIR/repo/"
    fi
done
"""

REFACTOR_SH: str = r"""#!/usr/bin/env bash
# this file was autogenerated by templates.py
set -e; set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
LOG_FILE="$SCRIPT_DIR/$(basename "$0")".log

cd "$SCRIPT_DIR/repo"

rm -f "$LOG_FILE"
ARTIFACT_ROOT="../../refactor-diffs"
PROJECT_NAME="$(basename "$SCRIPT_DIR")"
ARTIFACT_DIR="${ARTIFACT_ROOT}/${PROJECT_NAME}"
rm -rf "$ARTIFACT_DIR"
mkdir -p "$ARTIFACT_DIR"

diff_idx=0
while IFS= read -r transform; do
    [[ -z "$transform" ]] && continue

    # Print the index in 4 digit format with leading zeroes,
    # so the indices align just like in git outputs
    diff_idx4=$(printf "%04d" "${diff_idx}")
    : $((diff_idx++))

    DIFF_FILE="$ARTIFACT_DIR/${diff_idx4}_${transform}.diff"

    c2rust refactor \
        ${transform} \
        --cargo --lib \
        --rewrite-mode diff \
        >"$DIFF_FILE" \
        2>>"$LOG_FILE"

    if [[ -s "$DIFF_FILE" ]] && grep -q '^@@' "$DIFF_FILE"; then
        echo "Saved diff for ${transform} at ${DIFF_FILE}" >>"$LOG_FILE"
        patch -p1 --batch -F5 <"$DIFF_FILE" >>"$LOG_FILE" 2>&1
    else
        echo "No changes produced by ${transform}; leaving empty diff ${DIFF_FILE}" >>"$LOG_FILE"
    fi
done <<'C2RUST_TRANSFORMS'
{{transform_lines}}
C2RUST_TRANSFORMS
"""

CARGO_SH: str = r"""#!/usr/bin/env bash
# this file was autogenerated by templates.py
set -e; set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "$0" )" && pwd)"

# Do a release build in case the C code contains signed integer overflows
# that trap in a debug build.
(cd "$SCRIPT_DIR/repo" \
    && RUSTFLAGS="-Awarnings {{extra_rustflags}}" nice -n 19 cargo ${TOOLCHAIN} build --release 2>&1 | tee ../`basename "$0"`.log)

"""


def render_script(template: str, out_path: str, params: dict):
    out = Template(template).render(**params)

    with open(out_path, "w") as fh:
        fh.writelines(out)
    os.chmod(out_path, stat.S_IREAD | stat.S_IWRITE | stat.S_IEXEC)


def autogen_transpile(conf: str, yaml: dict[str, Any]) -> Generator[Path, None, None]:
    """
    Yield generated paths.
    """

    transpile = yaml.get("transpile")
    if not (transpile and isinstance(transpile, dict)):
        return
    
    ag = transpile.get("autogen")
    if not (ag and isinstance(ag, bool)):
        return
    
    params = {"binary": "--emit-build-files", "cflags": ""}

    binary = transpile.get("binary")
    if binary:
        params["binary"] = f"--binary {binary}"

    cflags = transpile.get("cflags")
    if cflags:
        if isinstance(cflags, list):
            cflags = " ".join(cflags)
        params["cflags"] = cflags

    tflags = transpile.get("tflags")
    if tflags:
        if isinstance(tflags, list):
            tflags = " ".join(tflags)
        params["tflags"] = tflags

    out_path = os.path.join(os.path.dirname(conf), "transpile.gen.sh")
    render_script(TRANSPILE_SH, out_path, params)
    yield Path(out_path)


def autogen_refactor(conf: str, yaml: dict[str, Any]) -> Generator[Path, None, None]:
    """
    Yield generated paths.
    """

    refactor = yaml.get("refactor")
    if not (refactor and isinstance(refactor, dict)):
        return
    
    ag = refactor.get("autogen")
    if not (ag and isinstance(ag, bool)):
        return
    
    params = {"transform_lines": ""}

    # Get list of transformations from config
    transforms = refactor.get("transforms")
    if transforms and isinstance(transforms, list):
        lines = [
            t.strip() for t in transforms if isinstance(t, str) and t.strip()
        ]
        if lines:
            params["transform_lines"] = "\n".join(lines)
    elif transforms and isinstance(transforms, str):
        stripped = transforms.strip()
        if stripped:
            params["transform_lines"] = stripped

    # Only generate script if we have transformations
    if params["transform_lines"]:
        out_path = os.path.join(os.path.dirname(conf), "refactor.gen.sh")
        render_script(REFACTOR_SH, out_path, params)
        yield Path(out_path)


def autogen_cargo(conf: str, yaml: dict[str, Any]) -> Generator[Path, None, None]:
    """
    Yield generated paths.
    """

    def render_stage(
        stage_conf: Mapping[str, Any] | None, filename: str
    ) -> Generator[Path, None, None]:
        """
        Yield generated paths.
        """

        if not isinstance(stage_conf, Mapping):
            return
        if not stage_conf:
            return

        ag = stage_conf.get("autogen")
        if not (ag and isinstance(ag, bool)):
            return

        params: dict[str, str] = {}
        rustflags = stage_conf.get("rustflags")
        if rustflags and isinstance(rustflags, str):
            params["extra_rustflags"] = rustflags

        out_path = os.path.join(os.path.dirname(conf), filename)
        render_script(CARGO_SH, out_path, params)
        yield Path(out_path)

    for key, fname in (
        ("cargo.transpile", "cargo.transpile.gen.sh"),
        ("cargo.refactor", "cargo.refactor.gen.sh"),
        ("cargo.postprocess", "cargo.postprocess.gen.sh"),
    ):
        yield from render_stage(yaml.get(key), fname)


def autogen(conf: Config) -> Generator[Path, None, None]:
    """
    Yield generated paths.
    """

    for cf, yaml in conf.project_conf.items():
        yield from autogen_transpile(cf, yaml)
        yield from autogen_refactor(cf, yaml)
        yield from autogen_cargo(cf, yaml)
